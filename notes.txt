- The prototype follows this article: http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-in-java-with-jersey-and-spring/
- There is a slight change from the article we will use postgres since I loath mysql x-( x-( 

- The demo uses a multi-layer architecture based on the "Law of Demeter"/"Pircinple of least knowledge"
- Layer 1 is the REST support implemented via Jersey, it has the role of a facade nad delegates the logic to the business layer
- The Business Layer is where the logic happens
- The data access layer is where communication with the persistance storage takes place

- Jersey Facade
  * Jersey RESTful framework is an open source, production quality framework for developing RESTful Web Services in Java which provides support for the JAX-RS API and
    serves as the JAX-RS flagship implementation

- Spring (Business Layer)
  * Spring DI beans and pojos are among the best in the Java world
  * It has a large community follwoing
  * It is the best way to create POJOs with different functionalities
  * And the best part is Jersey has a hook into the wonderful world of spring (https://jersey.java.net/documentation/latest/spring.html) :) :)

- JPA/Hibernate (Persistence Layer)
  * We will try with hibernate first, but at some point I want to try JOOQ (http://www.jooq.org/doc/3.5/manual/getting-started/tutorials/jooq-with-jax-rs/)
  * We will use the DAO patterrn in this instance for the persistence layer
  * We are using JPA 2, which according to most people makes DAOs superfluous (I hate cluttering the service layer with JPA/Entity Manteger code)
  * Hibernate is going to be used to support JPA 2

- Web Container
  * Maven is used as the deployer and packager into a .war file, this can be deployed to a tomcat or jetty server

- Postgres
  * I really really like postgres so I am using itt

- DB Import --> Do the following steps
  1. install mysql 5.6 or later onto your computer
  2. install postgre onto your computer
  3. insert the mysql dump file into the mysql server

	mysql -uroot -hlocalhost < ../jersey_spring_prototype/src/main/resources/input_data/DumpRESTdemoDB.sql

  4. dump the rest demo databse into a new dump file

	mysqldump --compatible=postgresql --default-character-set=utf8 -r rest_demo.mysql -uroot rest_demo

  5. Clone this repo

	git clone git@github.com:lanyrd/mysql-postgresql-converter.git

  6. Run the python file in that repo on your sql dump

      python db_converter.py rest_demo.mysql rest_demo.psql

  7. Import the rest_demo.psql into your psql server

      psql -d rest_demo -f rest_demo.psql

  8. Enjoy the awsomeness of postgres

- REST resources
  * Resources in this prototype represent podcasts
  * Resources are the central concept of REST are are characterized by two things

      1. Eahc is referenced by a global identifier (e.g. a URI in HTTP)
      2. Has one or more representations which they expose to the outer world (we will only concern ourselves with the JSON representation)

  * The endpoints in this prototype

      /podcasts --> represents a resources that is a collection of podcasts
      /podcasts/{id} --> URI identifying a podcast resource by the podcast's id

  * A podcast has the following properties

      1. id --> a unique identifer of the prodcast
      2. feed --> uri feed of the podcast
      3. title --> title of the podcast
      4. linkOnPodcastpedia --> where one can find the podcast on Podcastpedia.org
      5. description --> a short description of the podcast

  * We can use one one Java class for the representation of the podcast resource, however the class and it properties/methods will get cluttered with both JPA and
    XML/JAXB/JSON annotations
  * We should avoid this at all costs and use two representations

      - PodcastEntity.java - JPA annotated class used in the DB and business layers
      - Podcast.java - JAXB/JSON annotated class used in the facade (Jersey layer) and business layers

- Rest Methods

    - Create --> Post
    - Read --> Get
    - Update --> PUT
    - Delete --> DELETE

  * The above are not 1:1 mappings, you can also have PUT for creation and POST for updating
  * Read and Delete mata 1:1 to GET and DELETE
  * We must remember REST is an architectural style, it isn't a specification and you should adapt it to your needs
  * However if you are making your API public you still need to follow some best practices

- Resource.Config.java
  * This is used to register application resources, filters, exception mappers etc.

- PodcastResource.java
  * Acts as the controller in the JAX/RS world
  * The class is annotated with @Path("/podcasts") - everything related to podcast resources will occur under this path
  * The annotation is a relative URI
  * PodcastService interface exposes the business logic to the REST facade layer

- Creating Podcasts
  * The most known way of resource creation is using POST, but you can also use PUT as will
  * The differenct between POST vs. PUT

      - POST (not idempotent)
      - PUT (idempotent) --> with PUT you should know beforehand the location where the resource will be created and send all the possible values of the entry

- Creating a single resource with (POST --> /podcasts/ --> POST --> 201 Created)

	    @POST
	    @Consumes({ MediaType.APPLICATION_JSON })
	    @Produces({ MediaType.TEXT_HTML })
	    public Response createPodcast(Podcast podcast) throws AppException {
		Long createPodcastId = podcastService.createPodcast(podcast);
		return Response.status(Response.Status.CREATED)// 201
			.entity("A new podcast has been created")
			.header("Location",
				"http://localhost:8888/demo-rest-jersey-spring/podcasts/"
					+ String.valueOf(createPodcastId)).build();
	    }

  Annotations
    * @POST --> this annotation indicates tht the method responds to HTTP POST requests
    * @Consumes({ MediaType.APPLICATION_JSON }) --> this defines the media type that this method accepts, in this case application/json
    * @Produces({MediaType.TEXT_HTML}) --> defines the media type that the method can produce, in this case "text/html"

  Response
    * on success the method produces text/xml, with an HTTP status of 201 Created, and a location header which specifies where the resource was created
    * on error one of two things can happen
      400 Bad request if not enough data is provided
      409 Conflict if on the server side it is determined a podcast with the same feed exists

- Creating a single resource with PUT will be same as updating a resource on the server

- Creating a single podcast from a form (POST --> /podcasts/ --> 201 Created)


	/**
	 * Adds a new podcast (resource) from "form" (at least title and feed
	 * elements are required at the DB level)
	 * 
	 * @param title
	 * @param linkOnPodcastpedia
	 * @param feed
	 * @param description
	 * @return
	 * @throws AppException
	 */
	@POST
	@Consumes({ MediaType.APPLICATION_FORM_URLENCODED })
	@Produces({ MediaType.TEXT_HTML })
	@Transactional
	public Response createPodcastFromApplicationFormURLencoded(
		@FormParam("title") String title,
		@FormParam("linkOnPodcastpedia") String linkOnPodcastpedia,
		@FormParam("feed") String feed,
		@FormParam("description") String description) throws AppException {
	 
	    Podcast podcast = new Podcast(title, linkOnPodcastpedia, feed,
		    description);
	    Long createPodcastid = podcastService.createPodcast(podcast);
	 
	    return Response
		    .status(Response.Status.CREATED)// 201
		    .entity("A new podcast/resource has been created at /demo-rest-jersey-spring/podcasts/"
			    + createPodcastid)
		    .header("Location",
			    "http://localhost:8888/demo-rest-jersey-spring/podcasts/"
				    + String.valueOf(createPodcastid)).build();
	}

  Annotations
  * @POST - this indicates the method responds to HTTP POST requests
  * @Consumes({MediaType.APPLICATION_FORM_URLENCODED})- defines the media type the method accepts, in this case"application/x-www-form-urlencoded"
  * @FormParam – present before the input parameters of the method this annotation binds the value(s) of a form parameter contained within a request
		 entity body to a resource method parameter. Values are URL decoded unless this is disabled using the Encoded annotation
  * @Produces({MediaType.TEXT_HTML}) – defines the media type that the method can produce, in this case “text/html”. The response will be a html document
				       with a status of 201, indicating to the caller that the request has been fulfilled and resulted in a new resource being created.

  Response
  * on sucess text/html is returned with a HTTP status of 201 created, and a Location header spcifying where the resource has been created
  * on error one of two things can happen
    400 Bad request if not enough data is provided
    409 Conflict is on the server side it has been determined a podcast with the same feed exists

- Reading All Podcasts (GET --> /podcasts/?orderByInsertionDate={ASC|DESC}&numberDaysToLookBack={val} --> 200 OK)

	  /**
	   * Returns all resources (podcasts) from the database
	   * 
	   * @return
	   * @throws IOException
	   * @throws JsonMappingException
	   * @throws JsonGenerationException
	   * @throws AppException
	   */
	  @GET
	  @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
	  public List<Podcast> getPodcasts(
		  @QueryParam("orderByInsertionDate") String orderByInsertionDate,
		  @QueryParam("numberDaysToLookBack") Integer numberDaysToLookBack)
		  throws JsonGenerationException, JsonMappingException, IOException,
		  AppException {
	      List<Podcast> podcasts = podcastService.getPodcasts(
		      orderByInsertionDate, numberDaysToLookBack);
	      return podcasts;
	  }

    Annotations
    * @GET means that the method responds to an HTTP GET request
    * @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) defines the media type that the method produces, in this case it is either "applicaiton/json"
      or "application/xml" (The Podcast class must have @XmlRootElement in order for this to work). The response is wither a list of podcasts either in JSON or XML format

    Response
    * The list of podcasts from the database and an HTTP status of 200 OK

- Reading a single podcast (GET -->  /podcasts/{id} --> 200 OK)

      @GET
      @Path("{id}")
      @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
      public Response getPodcastById(@PathParam("id") Long id)
	      throws JsonGenerationException, JsonMappingException, IOException,
	      AppException {
	  Podcast podcastById = podcastService.getPodcastById(id);
	  return Response.status(200).entity(podcastById)
		  .header("Access-Control-Allow-Headers", "X-extra-header")
		  .allow("OPTIONS").build();
      }

    Annotations
    * GET means that the method responds to an HTTP GET request
    * @Path("{id}") - identifies the URI path that the class method will serve requests for, "id" is an embedded variable making an URI path template and is used with the
      @PathParam variable
    * @PathParam("id") - this binds the value of a URI template parameter ("id") to the resource method parameter. The value will be URL decoded unless this is deisabled
      using the @Encoded annotation. A default value can be specified using the @DefaultValue annotation
    * @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) defines the media type that the method produces, in this case it is either "applicaiton/json"
      or "application/xml" (The Podcast class must have @XmlRootElement in order for this to work). The response is wither a list of podcasts either in JSON or XML format

    Response
    * if successful the requested podcast with a 200 OK status is returned; the format is either xml or JSON, depending on what the accept header value is sent by the client
    * if an error occurs a 404 Not Found is returned if no podcast with the given id is found

- Updating Podcasts
  * In REST there are two types of updates

      1. full updates - this is where you will provide all properties for a resource
      2. partial updates - this is when only some properties will be sent over for update

  * For full updates one can use PUT and you will be conforming to the JAX-RS specification but hardly anyone ever does this
  * There is a war going on with partial updates as to what to use to do the update

      1. via PUT
      2. via POST
      3. via PATCH

  * Most people consider PUT a no go for partial updates because based on language in the specification

      "If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server."

  * If for example you only want to update the title property of a podcast with id 2


	PUT http://localhost:8888/demo-rest-jersey-spring/podcasts/2 HTTP/1.1
	Accept-Encoding: gzip,deflate
	Content-Type: application/json
	Content-Length: 155
	Host: localhost:8888
	Connection: Keep-Alive
	User-Agent: Apache-HttpClient/4.1.1 (java 1.5)
	 
	{
	    "title":"New Title"
	}

    According to the specification the resource stored at the location should only have an id and a title property, in our case this is not the case

  * Hence why everyone abuses POST and this is the implementation within the prototype although it does not condform to the specification for POST

      "The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup
      to which it is posted, or a record is subordinate to a database."

    The above case clearly shows a POST does not conform to a partial update of a resource

  * Finally there is PATCH

      "Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing
      HTTP PUT method only allows a complete replacement of a document. This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource."

      - Not used, and is only a proposal may be rejected like so many things are
      - It's not even implemented in Jersey or an JAX-RS specification

  * The demo uses a partial update via POST

- Full update (PUT -->  /podcasts/{id} --> either 201 Created if podcast is created or 200 OK if podcast updated)


	@PUT
	@Path("{id}")
	@Consumes({ MediaType.APPLICATION_JSON })
	@Produces({ MediaType.TEXT_HTML })
	public Response putPodcastById(@PathParam("id") Long id, Podcast podcast)
		throws AppException {
	 
	    Podcast podcastById = podcastService.verifyPodcastExistenceById(id);
	 
	    if (podcastById == null) {
		// resource not existent yet, and should be created under the
		// specified URI
		Long createPodcastId = podcastService.createPodcast(podcast);
		return Response
			.status(Response.Status.CREATED)
			// 201
			.entity("A new podcast has been created AT THE LOCATION you specified")
			.header("Location",
				"http://localhost:8888/demo-rest-jersey-spring/podcasts/"
					+ String.valueOf(createPodcastId)).build();
	    } else {
		// resource is existent and a full update should occur
		podcastService.updateFullyPodcast(podcast);
		return Response
			.status(Response.Status.OK)
			// 200
			.entity("The podcast you specified has been fully updated created AT THE LOCATION you specified")
			.header("Location",
				"http://localhost:8888/demo-rest-jersey-spring/podcasts/"
					+ String.valueOf(id)).build();
	    }
	}

    Annotations
    * @PUT - this indicates that the method responds to HTTP PUT requests
    * @Path("{id}") - identifies the URI path that this method will serve requests for. "id" is an embedded variable making an URI path template and is used in
      conjunction with the @PathParam variable
    * @PathParam("id") - this binds the value of the URI template parameter ("id") to the resource method parameter. Ths value if URI decoded unless it is disabled with
      the @Encoded annotation. A default value can be specified using the @DefaultValus annotation
    * @Consumes({MediaType.APPLICATION_JSON}) defines the media type which this method accepts, in this case application/json
    * @Produces({MediaType.TEXT_HTML}) - defines the media type that the method produces, in this instance it is text/html

  - The above method produces an HTML document containing different messages and stati depending on what action was taken and what the outcome is

    Response
    * on creation and successful a 201 Created status is sent and in the Location header the specified location where the resource was created is sent
    * on creation and  error a 400 Bad Request status is sent if the minimum required properties have not been provided for insertion
    * on full update and successful 200 OK status is sent
    * on error 400 Bad Request is sent if not all properties are provided

- Partial Update (PUT -->  /podcasts/{id} --> 200 OK if podcast updated)

	@POST
	@Path("{id}")    
	@Consumes({ MediaType.APPLICATION_JSON })
	@Produces({ MediaType.TEXT_HTML })
	public Response partialUpdatePodcast(@PathParam("id") Long id, Podcast podcast) throws AppException {
	    podcast.setId(id);
	    podcastService.updatePartiallyPodcast(podcast);
	    return Response.status(Response.Status.OK)// 200
		    .entity("The podcast you specified has been successfully updated")
		    .build();    
	}

  Annotations
  * @POST - this indicates that the method responds to an HTTP POST
  * @Path("{id}") - identifies the URI path that this method will serve requests for. "id" is an embedded variable making an URI path template and is used in
    conjunction with the @PathParam variable
  * @PathParam("id") - this binds the value of the URI template parameter ("id") to the resource method parameter. Ths value if URI decoded unless it is disabled with
    the @Encoded annotation. A default value can be specified using the @DefaultValus annotation
  * @Consumes({MediaType.APPLICATION_JSON}) defines the media type which this method accepts, in this case application/json
  * @Produces({MediaType.TEXT_HTML}) - defines the media type that the method produces, in this instance it is text/html

  Response
  * on successful partial update 200 OK is returned
  * on error of partial update 404 Not Found if there is no resource at the provided location

- Deleteing Podcasts

  - Delete all of the resources (DELTE -->  /podcasts/ --> 204 No content)

      @DELETE
      @Produces({ MediaType.TEXT_HTML })
      public Response deletePodcasts() {
	  podcastService.deletePodcasts();
	  return Response.status(Response.Status.NO_CONTENT)// 204
		  .entity("All podcasts have been successfully removed").build();
      }

    Annotations
    * @DELETE - this indicates that the method responds to the HTTP DELETE verb
    * @Produces({MediaType.TEXT_HTML}) - the method produces a response of text/html

    Response
    * the response is an html document, with a status of 204 No Content, indicating to the caller that the request has been fulfilled


  - Delete a single resource

	@DELETE
	@Path("{id}")
	@Produces({ MediaType.TEXT_HTML })
	public Response deletePodcastById(@PathParam("id") Long id) {
	    podcastService.deletePodcastById(id);
	    return Response.status(Response.Status.NO_CONTENT)// 204
		    .entity("Podcast successfully removed from database").build();
	}

    Annotations
    * @DELETE - this indicates that the method responds to the HTTP DELETE verb
    * @Path("{id}") - identifies the URI path that this method will serve requests for. "id" is an embedded variable making an URI path template and is used in
      conjunction with the @PathParam variable
    * @PathParam("id") - this binds the value of the URI template parameter ("id") to the resource method parameter. Ths value if URI decoded unless it is disabled with
      the @Encoded annotation. A default value can be specified using the @DefaultValus annotation
    * @Consumes({MediaType.APPLICATION_JSON}) defines the media type which this method accepts, in this case application/json
    * @Produces({MediaType.TEXT_HTML}) - defines the media type that the method produces, in this instance it is text/html

    Response
    * on success the podcast is removed and a 204 No Content success status is returned
    * on error the podcast is not available anymore and a status of 404 Not found is returned

- Logging
  * Every request path and response entity is logged when the loggin level is set to DEBUG.
  * It is developed like a wrapper, AOP-style functionality with the help of Jetty filters

- Exception Handling
  * IN the case of errors, a response with a unified error message structure is created

	{
	   "status": 400,
	   "code": 400,
	   "message": "Provided data not sufficient for insertion",
	   "link": "http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-with-jersey-and-spring",
	   "developerMessage": "Please verify that the feed is properly generated/set"
	}

- CORS support
  * We support cros-origin resource sharing on the server side

	@Provider
	public class CORSResponseFilter implements ContainerResponseFilter {

	    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
		    throws IOException {

		MultivaluedMap<String, Object> headers = responseContext.getHeaders();

		headers.add("Access-Control-Allow-Origin", "*");
		//headers.add("Access-Control-Allow-Origin", "http://podcastpedia.org"); //allows CORS requests only coming from podcastpedia.org
		headers.add("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
		headers.add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, X-Codingpedia");
	    }
	}


  * we are setting the neccessary "Access-Control-Allow-*" HTTP header in the Filter class above, spring adds these headers to each HTTP response that it sends out
  
Fail Sade Plugin
- The Failsafe Plugin is used during integration tests and verification phases of the build lifecycle to execute integration tests
- The Failsafe Plugin will not fail the build during the integration test phase enabling the post integration test phase to execute

Jetty Maven Plugin
- The integration testss are executed against a running jetty server, that will be started only for the execution of the tests
- In the pre-integration-test phase the Jetty server is started, after stopping any running instance to free up the port, and the post-integration-phase
  it is stopped
  * canIntervalSeconds has to be set at 0 and the daemon to true

Builfing the integration tests
- JUnit is the testing framework that is being used, by default Failsafe plugin includes all test classes
  with the following wildcard patterns
  
    "**/IT*.java" – includes all of its subdirectories and all java filenames that start with “IT”.
    "**/*IT.java" – includes all of its subdirectories and all java filenames that end with “IT”.
    "**/*ITCase.java" – includes all of its subdirectories and all java filenames that end with “ITCase”.
    
Integration Test Example:

public class RestDemoServiceIT {
 
            [....]
            @Test
            public void testGetPodcast() throws JsonGenerationException,
                    JsonMappingException, IOException {
         
                ClientConfig clientConfig = new ClientConfig();
                clientConfig.register(JacksonFeature.class);
         
                Client client = ClientBuilder.newClient(clientConfig);
         
                WebTarget webTarget = client
                        .target("http://localhost:8888/demo-rest-jersey-spring/podcasts/2");
         
                Builder request = webTarget.request(MediaType.APPLICATION_JSON);
         
                Response response = request.get();
                Assert.assertTrue(response.getStatus() == 200);
         
                Podcast podcast = response.readEntity(Podcast.class);
         
                ObjectMapper mapper = new ObjectMapper();
                System.out
                        .print("Received podcast from database *************************** "
                                + mapper.writerWithDefaultPrettyPrinter()
                                        .writeValueAsString(podcast));
         
            }
        }
        
    * We had to register the Jackson Feature for the client so that we can marshall the podcast response into JSON format
      response.readEntity(Podcast.class)
    * We should expect a 200 status for the request
    * org.codehaus.jackson.map.ObjectMapper desiplays the JSON response pretty formatted
